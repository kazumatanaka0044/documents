チーム開発演習コーディング規約

演習規約5-4.コーディング規約・命名規約についての規約を遵守するものとする
  ・全てのクラス、全てのメンバ（メソッド、フィールド、定数など）に、Javadoc 形式のコメントを記述すること。
    ただし、インターフェイス内のメソッドに Javadoc が記載されている場合、実装クラス内でオーバーライドしたメソッドの Javadoc は省略可能とする。
  ・クラス名、メソッド名、フィールド名については、サンプルコードと同等の命名規則に従うこと。

ファイル構成
　個別規約
　(1)ファイル名
	publicクラスはクラス名と同一ファイル名とし、1クラス1ファイルにしてください。
	　【例: public class Point は、Point.java に入れます。】

命名規則
　個別規約

　(1) クラス名
	先頭と単語の区切りを大文字とします。自律と再利用性を考慮したプログラム単位と名前付けをしてください。
	 【例: SendAccountingFaxGenerator】

　(2) 日本語と英語。
	全ての識別子の名前は中学生までに学習する程度の英単語を基本とします
	ただし日本固有の名詞や、無理に英訳することでかえって可読性が低下する場合は、ローマ字を使用してください。
	 【例：userAddress(キャメルケース)】
	 【例：user_address(スネークケース)】

　(3) 無意味な名前
	temp、str、buf といった無意味な変数名は再考を要します
	 【悪い例: double temp = (182 + 170 + 173 + 165 + 169) / 5;】
	 【良い例: double averageHeight = (182 + 170 + 173 + 165 + 169) / 5;】
　
(4) boolean変数
	接頭語として is+形容詞、can+動詞、has+過去分詞を使用します
	 【例: boolean isEmpty】
	 【例: boolean canClose】

　(5) ループカウンタ
	for 文のループカウンタ名は慣習的に i を使用します。for 文をネストする際は、一番外側のループカウンタから順に i、j、k という名前を使います。

　(6) メソッド名
	小文字で始まり、単語の区切りを大文字とし、機能を表すネーミングにします。
	 【例: updateEntryAcceptAndDeliver()】

　(7) スコープが異なる変数
	スコープが異なると同一の変数名が許されますが、これが起因したバグを誘発することがあります。
　　  　そのため、インスタンス変数と同名のローカル変数が存在する場合、インスタンス変数アクセス時には、thisを使用しましょう。

　(8) 意味が読み取れる名前
	メソッドの引数は、どのようなデータが代入されているか読み取れる名前とします。
	 【悪い例: copy(s1, s2)】
	 【良い例: copy(from, to) あるいは copy(source, destination)】

　(9) 定数
	定数は static final とし、名前は全て大文字とします。単語間は「_」繋いでください。
	 【例: UPPER_CASE_WITH_UNDERSCORES】

　(10) パッケージ名
	インターネット上にソースコードを公開する場合、パッケージ名が重複しないように、インターネットのドメイン名を逆さまにしたパッケージ名を使います。
	 【例: jp.co.yahooo.ファイル名】

　(11) 例外クラス名
	独自例外クラスを作成する際は、接尾語を Exception としたクラス名とします。
	 【例: ClassNameEndsWithException】

　(12) 属性の取得メソッド(getter)
	接頭語として get を付与します。(JavaBeans の仕様に準拠) boolean の属性の場合は is+形容詞、can+動詞、has+過去分詞とします。
	 【良い例: AnyType getAnyProp()】
	 【良い例: boolean isEnabled()】
	 【良い例: boolean hasChanged()】
	 【悪い例: boolean empty() //空にするという動詞的な意味に取れてしまいます。】

　(13) 属性の取得メソッド(setter)
	接頭語として set を付与します。（JavaBeans の仕様に準拠) boolean の属性の場合は、on や off を使用しても構いません。原則、setter の戻り値は void とします。
	 【例: void setAnyProp (AnyType value)】
	 【例: void onEnable()】
	 【例: void setEnable(boolean flag)】

　(14) スコープが狭い名前
	スコープが狭い変数名は、型名を略したものを使用しても構いません。
	 【例: ServeletContext sc = getServletContext();】

　(15) 大文字小文字の分け方
	大文字と小文字は異なる文字として扱われますが、大文字小文字違いの同じ名前を付けることは禁止とします。大文字で始まる名前はクラス名、インターフェイス名及び抽象クラス名、定数のみとします。
　
ガイドライン
　個別規約

　(1) 宣言と初期化
	変数に値が代入されていない状態で使用されるのを防ぐため、ローカル変数は初期値と共に宣言します。
	------------------------------
	 【悪い例】
	 void f(int start) {
	    int i、 j; // 初期値なしの宣言
	    i = start + 1;
	    j = i + 1; // i、 j を使用
	 }
	 【良い例】
	　void f(int start) {
	    int i = start + 1; // 使う前に宣言と初期化
	    int j = i + 1; // i、 j を使用
	 } 
	 ------------------------------
　(2) 大小比較演算子
	「<」、「<=」を好んで使い「>」、「>=」はなるべく避けてください。大小の方向を統一し、右側を大きい方にすることで混乱を避けます。ただし、定数との比較時には、定数を常に右側に置くことで可読性が上がることがあります。
	また、演算の中心となってコードに何度も記述する変数は、変数を常に左側に置くことで可読性が上がることがあります。

　(3) if文、switch文のネスト
	3 階層以上の if 文のネスト、2 階層以上の switch 文のネストは避けます。
	 --------------------------
	【悪い例(if文のネスト))
	 if(id == 3) {
	    if(age == 10) {
	       if(point > 15) {
		 ・・・
		}
	     }
	  }
	 【良い例(if文のネスト)】
	　if(id == 3 && age == 10 && point > 15) {
 	　　　・・・
	　}
	 --------------------------
	 【悪い例(switch文のネスト)】
	　switch (id) {
	　case 1:
	　switch (age) {
	　　　case 10:
	　　　・・・
	　　　break;
	　　　・・・
	　　}
	　　break;
	　case 2:
	　　・・・
	　　break;
	　}
	 【良い例(switch文のネスト)】
	　switch (id) {
	　case 1:
	　2 階層目の switch 文を実行するメソッド
	　break;
	　case 2:
	　・・・
	　break;
	　} 
	 --------------------------
	　switch 文の場合、2 階層目の switch 文をメソッドとして定義し、そのメソッドを呼び出すことでネストを避けます。

　(4) 配列宣言は型の一部として扱う
	配列の宣言は、Type[] arrayName とします。Type arrayName[]は C からの名残として残っているに過ぎません。
	 【悪い例: static void main(String args[]);】
	 【良い例: static void main(String[] args);】

　(5) 1つのメソッドに1つの役割とする
	メソッドの処理は複雑にせず、できるだけ単純にしてください。一つのメソッドに多くの役割を持たせてしまうと、ソースコードの再利用性が下がってしまいます。

　(6) メソッドへの出力は避ける
	メソッドの引数は入力であり、出力としては使うべきではありません。出力引数に新たなインスタンスを代入しないよう注意しましょう（新たなインスタンス代入すると通知されないため）。
	 --------------------------
	【悪い例】
	 void moveX(Point p, int dx) {
	     p.setX(p.getX()+dx); // 引数を変更(なるべく避けましょう)
	 }
	 void moveX(Point p, int dx) {
	     p = new Point(p.getX()+dx, p.getY()); // これは呼び出し側には伝わりません
	 }
	 --------------------------
　(7) publicなフィールドは作らない
	外部のクラスからフィールドに勝手にアクセス出来てしまうと、バグを誘発する恐れがあります。そのため、フィールドは private にしてアクセサメソッドを設けてください。

　(8) デフォルトコンストラクタでも明記する
	デフォルトコンストラクタ(引数・処理なしのコンストラクタ)は省略可能ですが、なるべく記述しましょう。

　(9) finalを好め
	インスタンス変数が作成された後も値が変化しない場合、その変数には final を付与しましょう。
	また、メソッドの引数の参照先を変更したくない場合も final にしましょう。その理由は、final はコンパイルの効率化等が適用されやすいためです。

　(10) オブジェクトの同値比較
	オブジェクトの比較では equals()メソッドを使い、「==」を使用しません。特に String の比較では「==」を使用してはならないため注意しましょう。

　(11) インターフェイスを多用する
	Java の抽象クラス(abstract class)は一つしか継承できないため、拡張性を犠牲にしてしまいます。なるべく interface を使用しましょう。

　(12) importの*は使用しない
	クラスを import する際、保守性の観点より「*」は使用しないようにしましょう。どのクラスを利用しているのかが見えなくなってしまうためです。

　(13) 例外クラス
	むやみに独自例外クラスを作成せず、まずは JDK 標準パッケージに含まれている例外で要件を満たせるか考えるようにしてください。

　(14) 多重初期化は避ける
	２度の変数の初期化は避けてください。
	 --------------------------
	【悪い例】
	 class PoorInitialization {
	    private name = “initial_name”;
	    name = “initial_name”;
	    ...
	 }
	 --------------------------
　(15) コーディングstyle
	コーディングスタイルは Coding Standards for Java に準拠します。
	http://www.ambysoft.com/downloads/javaCodingStandards.pd
	インデントは基本的に K&R の C 言語スタイルと同じですが、クラスおよびメソッドの定義開始の { を改行せずに書きます。最大の注意点は、必ずインデントを守ることです。
	インデントが狂っているソースは、バグと認定されても仕方がないため、インデント文字は Tab キーを使用し 4 字下げ表示とします。

　(16) 長い行は適宜改行する
	一行は原則 120 桁以内とし、それを超える場合は行を分割します。
	分割の方針は以下の通りです。

	方針 1: ローカル変数を利用します
	方針 2: 優先度の低い演算子の前で改行します
	 --------------------------
	 【例:double length = Math.sqrt(Math.pow(Math.random(), 2.0) + Math.pow(Math.random(), 2.0));】
	 【方針1】
	 double xSquared = Math.pow(Math.random(), 2.0);
	 double ySquared = Math.pow(Math.random(), 2.0);
	 double length = Math.sqrt(xSquared + ySquared);
	 【方針2】
	 double length = Math.sqrt(Math.pow(Math.random() //改行
	 + Math.pow(Math.random(), 2.0);
	 --------------------------
	またクラス、メソッドの宣言が長い場合の分割の指針を上げると以下のようになります
	方針 3: カンマで改行して頭合わせをします
	方針 4: extends と implements/throws 節で改行します
	 --------------------------
	 【方針3】
	 public void longMethodSignature(int a, int b, int c, 
	 int d, int e, int f) {
 	    …
	 }
	 【方針4】
	 public class LongNameClassImplemenation
	  		    extends AbstractImplementation,
 	 		    implements Serializable, Cloneable {
	   …
	 }
	 --------------------------
　(17) 変数隠しはしない
	スーパークラスの変数名と同じ変数名をサブクラスで使う事は避けましょう。

　(18) toString()は習慣化する
	JavaBeans のクラスには toString()メソッドを必ず実装します。それ以外のクラスでもできるだけ実装するようにしましょう。これによりデバッグやログ書き出しが容易になります。

　(19) コレクション
	環境が許せば JDK1.2 以降のコレクションクラスを用いましょう。すなわち Vector、Hashtable、
	Enumeration ではなく ArrayList、HashMap を使います。

	理由 1 : より簡潔で論理的、一貫性のあるメソッド名が使えます。
	理由 2 : List、Set、Map により、インターフェイスを変更せずに実装を取り替えることが可能です。
	理由 3 : 同期化がオプションであるため、より高速なコードが書ける可能性があります。


コメント
　個別規約
　
  (1) //と/**/
	 --------------------------
	【例】
	 /*
	 * …
	 * …
	 * …
	 */
	 --------------------------
  (2) Javadocの活用
	 Javaのコメントには3種類あります
	 --------------------------
	【例】
	 /** */ HTML 形式でドキュメント出力される JavaDoc コメントです。
	 /* */ 内部的な複数行コメントです。
	 // 内部的な単一行コメントです。
	 --------------------------
　(3) Javadocタグ
	「/** */」コメント中の「@」から始まる Javadoc タグの中でも、特に用いるものは以下のとおりです。Javadoc タグはクラス、メソッド、コンストラクタに対し用いてください。
	 -------------------------- 
	【例】
	 @author 作成者名
	 @param 引数名 引数の説明
	 @return 戻り値の説明
	 @throws 発生する例外クラス名 例外の説明
	 @see 参照先のクラス名、メンバ名
	 --------------------------
　(4) 長いコメント
	メソッドやクラスの内部的なコメントは「//」を使用します。「/* */」はバグを誘引する可能性があるためなるべく使用しないようにしてください。使用する場合は、各行の先頭に「*」置きましょう。

　(5) ソースの修正履歴には単一業のコメントを使用する
	Java のコメントには 3 種類あります。

	「/** */」コメントは機能概要、すなわち外部的な仕様の記述に用い、クラス及びメソッド、クラス変数、インスタンス変数の定義が始まる直前に書きます。
	コメントの 1 行目は、JavaDoc の概要ページに使用されるので特別な意味を持っています。この２行目以降に機能を説明します。
	Eclipse では「Alt+Shift+J」で自動的にコメントが付与され、HTML 形式でのドキュメントに変換することができます。

  (3) Javadocタグ
	「/** */」コメント中の「@」から始まる Javadoc タグの中でも、特に用いるものは以下のとおりです。Javadoc タグはクラス、メソッド、コンストラクタに対し用いてください。

パフォーマンス
　個別規約
	
　(2) 余分なnewを避ける
	Java では、new を使って生成したオブジェクトはメモリや CPU に保管されます。そのため、何度も newを使ってオブジェクトを生成すると、メモリや CPU に負荷がかかってしまい処理速度に影響が出てしまい
	ます。これを防ぐために、余計に new を使ってオブジェクトを生成することは避けるようにしましょう。

　(3) 変数へのnullの代入
	Java では、不要になったインスタンスのメモリ領域を開放するガーベッジコレクションと言う仕組みを持っています。
	インスタンスのメモリ領域が開放されるのは、そのインスタンスがどのプログラムからも変数を介して参照されなくなったときです。
	使用しなくなったインスタンスを意図的に通知するためには、変数に null を代入します